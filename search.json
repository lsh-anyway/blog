[{"title":"搭建Vue + Express开发环境","url":"/blog/搭建Vue-Express开发环境/","content":"项目地址：https://github.com/lsh-anyway/vue-express-dev-template\n# 准备工作\n\n使用 vue-cli 脚手架快速构建项目\n\n```bash\nvue init webpack vue-express-dev-template\n```\n\n生成的项目目录是这样的\n\n```\n.\n├── build\n│   ├── dev-server.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js\n│   ├── webpack.prod.conf.js\n│   └── ...\n├── config\n│   ├── dev.env.js\n│   ├── index.js\n│   └── prod.env.js\n├── src\n│   ├── main.js\n│   ├── App.vue\n│   ├── components\n│   │   └── ...\n│   └── assets\n│       └── ...\n├── static\n├── .babelrc\n├── .eslintrc.js\n├── index.html\n└── package.json\n```\n\n# 搭建 Express 服务器\n\n在项目根目录下创建 server 文件夹，用来放置后台相关的文件。完成后文件目录大致如下：\n\n```\n.\n├── build\n│   ├── dev-server.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js\n│   ├── webpack.prod.conf.js\n│   └── ...\n├── config\n│   ├── dev.env.js\n│   ├── index.js\n│   └── prod.env.js\n├── src     // 前端\n│   ├── main.js\n│   ├── App.vue\n│   ├── components\n│   │   └── ...\n│   └── assets\n│       └── ...\n├── server  // 后台\n│   ├── app.js\n│   ├── config\n│   │   └── ...\n│   ├── controllers\n│   │   └── ...\n│   ├── models\n│   │   └── ...\n│   ├── routes\n│   │   └── ...\n│   └── public  // 前端代码 build 打包后生成文件的存放目录\n├── static\n├── dev-server.js   // 开发环境服务器启动文件\n├── prod-server.js  // 生产环境服务器启动文件\n├── .babelrc\n├── .eslintrc.js\n├── index.html\n└── package.json\n```\n\n## 创建 Express 实例\n在 server 文件夹下创建 app.js 文件，用于创建一个 Express 应用实例，内容如下\n\n```js\nconst express = require('express')\nconst logger = require('morgan')\nconst bodyParser = require('body-parser')\n\nconst app = express()\n\n// Routers\nconst api = require('./routes/api')\n\n// 中间件\napp.use(logger('dev'))\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: false }))\n\n// Routes\napp.use('/api', api)\n\nmodule.exports = app\n```\n\n### 安装依赖\n\n```bash\nnpm i -S express morgan body-parser\n```\n或者\n```bash\nyarn add express morgan body-parser\n```\n\n## 搭建开发环境\n\n### 修改 webpack 配置\n\n修改开发环境的 webpack 配置，主要是修改`bulid/webpack.dev.conf.js`文件，修改内容如下\n\n```js\n'use strict'\nconst utils = require('./utils')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst merge = require('webpack-merge')\nconst path = require('path')\nconst baseWebpackConfig = require('./webpack.base.conf')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n// const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')\n// const portfinder = require('portfinder')\n\n// const HOST = process.env.HOST\n// const PORT = process.env.PORT && Number(process.env.PORT)\n\nconst devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  // cheap-module-eval-source-map is faster for development\n  devtool: config.dev.devtool,\n\n  // these devServer options should be customized in /config/index.js\n  // devServer: {\n  //   clientLogLevel: 'warning',\n  //   historyApiFallback: {\n  //     rewrites: [\n  //       { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },\n  //     ],\n  //   },\n  //   hot: true,\n  //   contentBase: false, // since we use CopyWebpackPlugin.\n  //   compress: true,\n  //   host: HOST || config.dev.host,\n  //   port: PORT || config.dev.port,\n  //   open: config.dev.autoOpenBrowser,\n  //   overlay: config.dev.errorOverlay\n  //     ? { warnings: false, errors: true }\n  //     : false,\n  //   publicPath: config.dev.assetsPublicPath,\n  //   proxy: config.dev.proxyTable,\n  //   quiet: true, // necessary for FriendlyErrorsPlugin\n  //   watchOptions: {\n  //     poll: config.dev.poll,\n  //   }\n  // },\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env': require('../config/dev.env')\n    }),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.\n    new webpack.NoEmitOnErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: 'index.html',\n      inject: true\n    }),\n    // copy custom static assets\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.dev.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})\n\nmodule.exports = devWebpackConfig\n\n// module.exports = new Promise((resolve, reject) => {\n//   portfinder.basePort = process.env.PORT || config.dev.port\n//   portfinder.getPort((err, port) => {\n//     if (err) {\n//       reject(err)\n//     } else {\n//       // publish the new Port, necessary for e2e tests\n//       process.env.PORT = port\n//       // add port to devServer config\n//       devWebpackConfig.devServer.port = port\n//\n//       // Add FriendlyErrorsPlugin\n//       devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({\n//         compilationSuccessInfo: {\n//           messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],\n//         },\n//         onErrors: config.dev.notifyOnErrors\n//         ? utils.createNotifierCallback()\n//         : undefined\n//       }))\n//\n//       resolve(devWebpackConfig)\n//     }\n//   })\n// })\n```\n\n> 因为要用自己搭建的 Express 服务器，所以把 webpack-dev-server 相关的配置都注释掉或者删掉，然后把开发环境的配置 devWebpackConfig 导出\n\n### 创建开发环境服务器启动文件\n在项目根目录下创建 dev-server.js 文件，用于启动开发环境下的服务器。内容如下\n\n```js\nconst app = require('./server/app')\nconst webpack = require('webpack')\nconst webpackDevMiddleware = require('webpack-dev-middleware')\nconst webpackHotMiddleware = require('webpack-hot-middleware')\n\nconst config = require('./build/webpack.dev.conf')\n\nconst compiler = webpack(config)\n// webpack 中间件\napp.use(webpackDevMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  stats: { colors: true }\n}))\n\napp.use(webpackHotMiddleware(compiler))\n\n// Start the server\nconst port = process.env.PORT || 3000\napp.listen(port, () => {\n  console.info(`Server listening at ${port}`)\n})\n```\n\n### 安装依赖\n\n```bash\nnpm i -D webpack-dev-middleware@1.12.2 webpack-hot-middleware\n```\n或者\n```bash\nyarn add -D webpack-dev-middleware@1.12.2 webpack-hot-middleware\n```\n\n> 这里要注意，最新版本的 webpack-dev-middleware 插件只支持 webpack4 ，然而我们要升级到 Webpack4 需要修改 extract-text-webpack-plugin , webpack.optimize.CommonsChunkPlugin 等插件的配置，太过于繁琐。所以我们这里使用 webpack-dev-middleware@1.12.2 \n\n现在，我们可以试下运行下面的命令，来启动开发环境的服务器\n```\nnode dev-server.js\n```\n\n## 搭建生产环境\n\n### 修改 webpack 配置\n\n修改生产环境的 webpack 配置，主要是修改`config/index.js`文件，修改内容如下\n\n```js\n'use strict'\n// Template version: 1.3.1\n// see http://vuejs-templates.github.io/webpack for documentation.\n\nconst path = require('path')\n\nmodule.exports = {\n  dev: {\n\n    // Paths\n    assetsSubDirectory: 'static',\n    assetsPublicPath: '/',\n    proxyTable: {},\n\n    // Various Dev Server settings\n    host: 'localhost', // can be overwritten by process.env.HOST\n    port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined\n    autoOpenBrowser: false,\n    errorOverlay: true,\n    notifyOnErrors: true,\n    poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-\n\n    // Use Eslint Loader?\n    // If true, your code will be linted during bundling and\n    // linting errors and warnings will be shown in the console.\n    useEslint: true,\n    // If true, eslint errors and warnings will also be shown in the error overlay\n    // in the browser.\n    showEslintErrorsInOverlay: false,\n\n    /**\n     * Source Maps\n     */\n\n    // https://webpack.js.org/configuration/devtool/#development\n    devtool: 'cheap-module-eval-source-map',\n\n    // If you have problems debugging vue-files in devtools,\n    // set this to false - it *may* help\n    // https://vue-loader.vuejs.org/en/options.html#cachebusting\n    cacheBusting: true,\n\n    cssSourceMap: true\n  },\n\n  build: {\n    // Template for index.html\n    // index: path.resolve(__dirname, '../dist/index.html'),\n    index: path.resolve(__dirname, '../server/public/index.html'),\n\n    // Paths\n    // assetsRoot: path.resolve(__dirname, '../dist'),\n    assetsRoot: path.resolve(__dirname, '../server/public'),\n    assetsSubDirectory: 'static',\n    assetsPublicPath: '/',\n\n    /**\n     * Source Maps\n     */\n\n    productionSourceMap: true,\n    // https://webpack.js.org/configuration/devtool/#production\n    devtool: '#source-map',\n\n    // Gzip off by default as many popular static hosts such as\n    // Surge or Netlify already gzip all static assets for you.\n    // Before setting to `true`, make sure to:\n    // npm install --save-dev compression-webpack-plugin\n    productionGzip: false,\n    productionGzipExtensions: ['js', 'css'],\n\n    // Run the build command with an extra argument to\n    // View the bundle analyzer report after build finishes:\n    // `npm run build --report`\n    // Set to `true` or `false` to always turn it on or off\n    bundleAnalyzerReport: process.env.npm_config_report\n  }\n}\n```\n\n> 主要是把webpack打包的输出文件夹改成了 server/public 文件夹\n\n### 创建生产环境服务器启动文件\n在项目根目录下创建 prod-server.js 文件，用于启动生产环境下的服务器。内容如下\n\n```js\nconst app = require('./server/app')\nconst express = require('express')\nconst path = require('path')\n// 设置HTTP头部，帮助增强Node.JS的Express/Connect等Javascript Web应用安全的中间件。\nconst helmet = require('helmet')\n\n// Middlewares\napp.use(helmet())\n\n// 静态文件目录\napp.use(express.static(path.join(__dirname, 'server/public')))\n\n// Catch 404 Errors and forward them to error handler\napp.use((req, res, next) => {\n  const err = new Error(\"Not Found\")\n  err.status = 404\n  next(err)\n})\n\n// Error handler function\napp.use((err, req, res, next) => {\n  const error = app.get(\"env\") === \"development\" ? err : {}\n  const status = error.status || 500\n  \n  // Response to client\n  res.status(status).json({\n    error: {\n      message: error.message\n    }\n  })\n  \n  // Response to ourselves\n  console.error(err)\n})\n\n// Start the server\nconst port = process.env.PORT || 4000\napp.listen(port, () => {\n  console.info(`Server listening at ${port}`)\n})\n```\n\n### 安装依赖\n\n```bash\nnpm i -S helmet\n```\n或者\n```bash\nyarn add helmet\n```\n\n到这里其实整个 Vue + Express 的全栈开发环境已经基本搭建完成了。接下来，我们试下用下面的命令来打包前端文件，然后在启动生产环境的服务器\n\n```hash\nnpm run build\n```\n\n```bash\nnode prod-server.js\n```\n\n> 注意：至少要打包一次前端代码后再启动生产环境的服务器，不然 server 文件夹下是没有 public 文件夹的\n\n# 修改项目配置\n\n## 修改 package.json\n\n```json\n{\n  \"name\": \"vue-express-dev-template\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Vue.js + Express Development Environment Template\",\n  \"author\": \"林烁壕 <1138674510@qq.com>\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"nodemon dev-server.js\",\n    \"start\": \"npm run dev\",\n    \"lint\": \"eslint --ext .js,.vue src\",\n    \"build\": \"node build/build.js\",\n    \"prod\": \"nodemon prod-server.js\"\n  },\n  ...\n}\n```\n\n## 创建 nodemon.json\n\n```json\n{\n  \"verbose\": true,\n  \"ignore\": [\"server/public/\"],\n  \"events\": {\n    \"restart\": \"osascript -e 'display notification \\\"App restarted due to:\\n'$FILENAME'\\\" with title \\\"nodemon\\\"'\"\n  },\n  \"watch\": [\"server/\"],\n  \"env\": {\n    \"NODE_ENV\": \"development\"\n  },\n  \"ext\": \"js\"\n}\n```\n\n## 安装依赖\n\n```bash\nnpm i -D nodemon\n```\n或者\n```bash\nyarn add nodemon -D\n```\n\n# 尾声\n这个项目到这里就已经构建完成了，接下来只要试着运行一下就可以了。\n\n**运行开发模式：**\n```\nnpm run dev\n```\n或者\n```\nnpm start\n```\n\n**打包前端代码：**\n```\nnpm run build\n```\n\n**运行生产模式：**\n```\nnpm run prod\n```\n","tags":["Express"]},{"title":"浏览器渲染HTML的流程","url":"/blog/浏览器渲染HTML的原理及流程/","content":"> # 介绍\n\n## 我们将讨论的浏览器\n\n目前有五种主流浏览器 - Internet Explorer，Firefox，Safari，Chrome和Opera。\n\n这里将举出三种开源浏览器的例子 - Firefox，Chrome和Safari是基于两种渲染引擎构建的，Firefox使用Geoko——Mozilla自主研发的渲染引擎，Safari和Chrome都使用webkit。\n\n## 浏览器的高级结构\n\n浏览器的主要组件是：\n\n- 用户界面 - 包括地址栏，后退/前进按钮，书签菜单等。浏览器的每个部分都显示除了主窗口，您可以看到请求的页面。\n- 浏览器引擎 - 查询和操作渲染引擎的界面。\n- 渲染引擎 - 负责显示请求的内容。例如，如果请求的内容是HTML，则它负责解析HTML和CSS并在屏幕上显示解析的内容。\n- 网络 - 用于网络呼叫，如HTTP请求。它具有与平台无关的接口和每个平台的底层实现。\n- UI后端 - 用于绘制组合框和窗口等基本小部件。它公开了一个不是平台特定的通用接口。它下面使用操作系统用户界面方法。\n- JavaScript解释器。用于解析和执行JavaScript代码。\n- 数据存储。这是一个持久层。浏览器需要保存硬盘上的各种数据，例如cookie。新的HTML规范（HTML5）定义了“web数据库”，它是浏览器中的完整（尽管是轻量级）数据库。\n\n> # 渲染引擎\n\n## 渲染引擎​​基本流程\n\n解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树\n\n![渲染引擎​​基本流程](../img/flow.png)\n\n## 主要流程示例\n\n> 当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。\n1.浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 \n2.将CSS解析成 CSS Rule Tree 。 \n3.根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了。\n4.有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。 \n5.再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。\n![](../img/Render-Tree.png)\n\n\n### Mozilla的Gecko渲染引擎主流\n![](../img/Geckoflow.jpg)\n### Webkit主流程\n![](../img/webkitflow.png)\n\n### 两个重要的概念\n- Reflow（回流）：当页面上某些元素的几何尺寸发生变化影响了布局，浏览器就会重新验证并计算Render Tree，这就是Reflow，或是Layout。 Reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。Reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 Reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 Reflow 哪一部分的代码，它们都彼此相互影响着。\n- Repaint（重绘）：当页面上某些元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性发生变化是时，将只引起浏览器的Repaint，重画某一部分。 \n\n> Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有Reflow方法，一个结点的Reflow很有可能导致子结点，甚至父点以及同级结点的Reflow。在一些高性能的电脑上也许还没什么，但是如果Reflow发生在手机上，那么这个过程是非常痛苦和耗电的。\n>\n>基本上来说，Reflow有如下的几个原因：\n> - Initial: 网页初始化的时候。\n> - Incremental: 一些Javascript在操作DOM Tree时。\n> - Resize: 其些元件的尺寸变了。\n> - StyleChange: 如果CSS的属性发生变化了。\n> - Dirty: 几个Incremental的Reflow发生在同一个frame的子树上。\n>\n> 当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就Reflow或Repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次Reflow，这又叫异步Reflow或增量异步Reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行Reflow。\n\n## 减少Reflow/Repaint\n一、不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className。\n\n二、把DOM离线后修改。如：\n- 使用documentFragment 对象在内存里操作DOM\n- 先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。\n- clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。\n\n三、不要把DOM结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。\n\n四、尽可能的修改层级比较低的DOM。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。\n\n五、为动画的HTML元件使用fixed或absoult的position，那么修改他们的CSS是不会reflow的。\n\n六、千万不要使用table布局。因为可能很小的一个小改动会造成整个table的重新布局。\n\n> # 处理脚本和样式表的顺序\n\n## 脚本\n网络的模型是同步的。作者期望脚本在解析器到达`<script>`标记时被解析并立即执行。文档解析暂停，直到脚本执行完毕。如果脚本是外部的，那么必须首先从网络获取资源 - 这也是同步完成的，解析将暂停直到资源被获取。这是多年的模式，并且在HTML 4和5规范中也有规定。作者可以将脚本标记为“defer”，因此它不会停止文档解析并在解析后执行。HTML5添加了一个选项，将脚本标记为异步，以便由另一个线程解析和执行脚本。\n\n## 样式表\n另一方面，样式表有不同的模型。从概念上看，由于样式表不会更改DOM树，所以没有理由等待它们并停止文档解析。不过，在文档分析阶段，脚本会询问样式信息。如果样式尚未加载并解析，脚本将得到错误的答案，显然这导致了很多问题。这似乎是一个边缘案例，但相当普遍。当有一个仍在加载和解析的样式表时，Firefox将阻止所有脚本。Webkit仅在脚本尝试访问某些可能受卸载样式表影响的样式属性时才阻止脚本。\n\n**因此我们一般会将样式文件放在header中，而将script标签放在body结束标签之前**\n\n>参考： http://taligarsiel.com/Projects/howbrowserswork1.htm\n","tags":["浏览器"]}]